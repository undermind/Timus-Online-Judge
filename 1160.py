import sys
#tokens = sys.stdin.read().split()
tokens=[4,6,1, 2, 1,1, 3, 1,1, 4, 2,2, 3, 1,3, 4, 1,2, 4, 1]
n=int(tokens[0])
m=int(tokens[1])
cables=[]
maxLen=0
for i in range(m):
    cables.append([int(tokens[i*3+2]),int(tokens[i*3+3]),int(tokens[i*3+4])])
#print(cables)
cables.sort(key=lambda x: x[2])
#print(cables)
nodes=[]
for i in range(n+1): nodes.append([0,i])
def findRoot(a):
    if a != nodes[a][1]: nodes[a][1] = findRoot(nodes[a][1])
    return nodes[a][1]

def merge(a,b):
    if nodes[a][0] > nodes[b][0]: nodes[b][1]=a
    else: 
        nodes[a][1] = b
        if nodes[a][0]==nodes[b][0]: nodes[b][0]+=1

for i in range (m):
    frm = cables[i][0]
    to = cables[i][1]
    if findRoot(frm) != findRoot(to):
        if cables[i][2] >maxLen: maxLen = cables[i][2]
        cables[i][2]*=-1
        merge(findRoot(frm),findRoot(to))

print(maxLen)
print(n-1)
for c in cables:
    if c[2]<0:print(c[0],c[1])

"""
Задача о нахождении минимального оставного дерева в графе, где вершинами будут 
выступать хабы, а провода - рёбрами графа. Необходимо пройти через все вершины 
так, чтобы сумма рёбер была минимальной. На выбор для реализации есть три известных 
алгоритма: Прима, Краскала и Буровки. Реализуем Краскала. Принцип работы таков: 
алгоритм изначального помещает все ребра графа G = (V, E) в собственное дерево, 
затем объединяя на два некоторых дерева ребром e = {u, v}. Изначально все рёбра 
сортируются по весу в порядке неубывания - если у текущего ребра его концы принадлежат 
разным поддеревьям, то эти поддеревья объединяются. По окончании перебора все V 
окажутся принадлежащими одному поддереву, и ответ найден. Cable отвечает за удобное 
хранение рёбер. Их сортировка потребует O(log(N)) операций, если использовать алгоритм 
из стандартной библиотеки C++. Затем нужно проверять соединяет ли ребро две 
различных компоненты связности графа. Эффективно реализовать это можно с помощью 
структуры данных DisjointSetUnion (Система непересекающихся множеств), создадим 
отдельный класс для работы с ней. Объединять компоненты связности будем методом 
merge(int a, int b), а проверять, находятся ли разные вершины графа в разных 
деревьях (т.е. компонентах связности) методом findRoot(int a). Для описания 
множества используется номер вершины, являющейся корнем соответствующего дерева. 
Для определения, принадлежат ли два элемента к одному и тому же множеству, для 
каждого элемента нужно найти корень соответствующего дерева (поднимаясь вверх 
пока это возможно) и сравнить эти корни. Объединяются множества так: пусть нам 
нужно объединить множества с корнями a и b. Просто присвоим p[a]=b, (где p - 
массив, хранящий прямого предка для каждой вершины), тем самым подвесив всё 
дерево a к корню дерева b. Можно заметить, что при такой реализации при постепенном 
объединении деревьев глубина будет расти вплоть до N. Применим несколько оптимизаций 
к структуре:
1. Ранги вершин: будем хранить для всех деревьев текущую глубину, и при объединении 
подвешивать дерево с меньшей глубиной к корню дерева с большей глубиной 
(в действительности, ранг вершины описывают не точную глубину дерева, а её верхнюю 
границу, но это не играет роли).
2. Сжатие путей: при поиске корня заданной вершины будем переподвешивать её за 
найденный корень. К примеру, мы вызвали findRoot для вершины, которую отделяют от 
корня дерева пять других вершин. Рекурсивный вызов функции обойдёт каждую из них, 
и найдёт корень. На выходе из каждого рекурсивного вызова обновим текущую вершину 
только что найденным корнем. Таким образом, все пять вершин теперь будут подвешены 
напрямую к корню.
P.S. В моей реализации объединим массивы p и массив рангов в массив объектов pair.
В конце выведем ответ. Максимальную длину рёбра можно было получить во время прохода 
по массиву рёбер, количество рёбер, соединяющих все точки будет равняться (n- 1), 
для любого количества точек (это можно заметить эмпирическим путём), а также выведем 
все рёбра, у которых длина > 0, так как во время вышеописанного цикла, необходимо 
отмечать уже использованные в графе рёбра - для этого можно просто менять знак веса 
ребра на противоположный.

"""